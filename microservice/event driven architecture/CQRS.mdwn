# CQRS 패턴

- Command Query Responsibility Separation Pattern
  - 데이더 저장소에 대한 **읽기** 및 **업데이트 작업**을 구분한다
  - 이로 인해서 업데이트에 대한 명령이 도메인 수준에서 병합 충돌을 일으키지 않을 수 있다.
    - 병합 충돌 lock

# 기존의 문제점

- 기존의 아키텍처
  - 데이터베이스를 쿼리하고 업데이트를 하는데, 동일한 데이터 소스를 사용
  - 문제점
    - update 와 read 에 대해 lock 이 걸리지 않으면 무결성이 깨짐
    - 하나의 데이터 자원(row) 에 작업을 병렬로 수행할 때, race condition 이 발생할 수 있음

# 해결 방법과 구현 방법

- 명령과 데이터를 읽는 쿼리를 분리하여 사용
  - 명령 : update
  - 쿼리 : read
- 구현 방법
  - 하나의 데이터소스 내에서 다른 스키마로 사용한다
  - 서로 다른 데이터 소스를 사용한다.

# 장점

- 독립적인 크기 조정 : 데이터 소스를 분리해서 구현한 경우에 읽기 전용 인스턴스만 확장시킬 수 있는 유연함이 있다.
  - 보통 read 8 : 2 write 이다
- 최적화된 데이터 스키마 : 읽기와 수정에 적합한 데이터베이스를 사용할 수 있다.
  - 읽기 전용과 수정 전용에 맞는 디비를 선택할 수 있음
  - 읽기 전용 데이터에 Materialized view 를 저장할 수 있음
- 단순한 쿼리 : 구체화된 뷰를 사용한다면 클라이언트 입장에서는 데이터를 요청하기만 하면 되므로 복잡한 조인을 방지할 수 있음

# 문제점

- 복잡성 : CQRS 의 개념은 간단하지만 CQRS 는 보통 이벤트 소싱과 함께 사용되므로 더욱 복잡한 애플리케이션이 설계될 수 있다
- 최종 일관성 : 데이터가 realtime 수준으로 일치하지 않음.

# CQRS를 사용하기 적합한곳과 적합하지 않은 곳

- 적합
  - 많은 사용자가 동일한 데이터에 병렬로 액세스 하는 작업이 많을 때
  - 읽기 수가 쓰기 수보다 훨씬 큰 경우
- 부적합
  - 도메인 또는 비즈니스 규칙이 간단한 서비스
  - 간단한 CRUD 의 작업이 주인 서비스
