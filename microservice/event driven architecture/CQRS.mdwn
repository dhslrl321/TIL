# CQRS 패턴

- Command Query Responsibility Separation Pattern
  - 데이더 저장소에 대한 **읽기** 및 **업데이트 작업**을 구분한다
  - 이로 인해서 업데이트에 대한 명령이 도메인 수준에서 병합 충돌을 일으키지 않을 수 있다.
    - 병합 충돌 lock

# 기존의 문제점

- 기존의 아키텍처
  - 데이터베이스를 쿼리하고 업데이트를 하는데, 동일한 데이터 소스를 사용
  - 문제점
    - update 와 read 에 대해 lock 이 걸리지 않으면 무결성이 깨짐
    - 하나의 데이터 자원(row) 에 작업을 병렬로 수행할 때, race condition 이 발생할 수 있음

# 레벨별 다른 cqrs 접근

- 레벨 1: 단일 data source 에 command 와 query 를 분리시킨다.
  - command model 과 query 모델을 분리시킬 수 있다
    - command model 에 비즈니스 로직이 들어있고 query model 은 비즈니스와 무관하다
    - 분리시키지 않는다면 도메인이 조회를 위한 작업으로 더러워질 수 있다
- 레벨 2: 서로 다른 data source 에 command 와 query 를 분리시킨다.
- 레벨 3: 이벤트 소싱을 적용시킨다.

# 해결 방법과 구현 방법

- 구현 방법
  - 하나의 데이터소스 내에서 다른 스키마로 사용한다
  - 서로 다른 데이터 소스를 사용한다.
    - 폴리그랏한 구조

# 장점

- 독립적인 크기 조정 : 데이터 소스를 분리해서 구현한 경우에 읽기 전용 인스턴스만 확장시킬 수 있는 유연함이 있다.
  - 보통 read 8 : 2 write 이다
- 최적화된 데이터 스키마 : 읽기와 수정에 적합한 데이터베이스를 사용할 수 있다.
  - 읽기 전용과 수정 전용에 맞는 디비를 선택할 수 있음
  - 읽기 전용 데이터에 Materialized view 를 저장할 수 있음
- 단순한 쿼리 : 구체화된 뷰를 사용한다면 클라이언트 입장에서는 데이터를 요청하기만 하면 되므로 복잡한 조인을 방지할 수 있음

# 문제점

- 복잡성 : CQRS 의 개념은 간단하지만 CQRS 는 보통 이벤트 소싱과 함께 사용되므로 더욱 복잡한 애플리케이션이 설계될 수 있다
- 최종 일관성 : 데이터가 realtime 수준으로 일치하지 않음.

# CQRS를 사용하기 적합한곳과 적합하지 않은 곳

- 적합
  - 많은 사용자가 동일한 데이터에 병렬로 액세스 하는 작업이 많을 때
  - 읽기 수가 쓰기 수보다 훨씬 큰 경우
- 부적합
  - 도메인 또는 비즈니스 규칙이 간단한 서비스
  - 간단한 CRUD 의 작업이 주인 서비스

오늘 엄청난 오해를 풀었습니다..
CQRS 는 Elasticsearch 와 RDB 같이 폴리그랏한 인프라를 구성하기 위해서 쓴다. 라고 이해했는데 그게 아니었습니다..
CQRS 시작은 핵심 비즈니스 로직이 존재하는 도메인 모델에 query 와 관련된 행위가 침투하는 것을 막기 위해서 둘을 분리시키는 것이었네요..
결국 하나의 data source 를 쓰더라도 cqrs 가 가능하고, cqrs 와 데이터 소스는 크게 연관이 없다는 결론.
