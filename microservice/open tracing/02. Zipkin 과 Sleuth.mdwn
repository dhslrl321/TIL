[Distributed Tracing] Spring Cloud Sleuth 와 Zipkin

[##_Image|kage@r4JA9/btrAR736lDt/jzAcvz59orEByhKDlwn810/img.png|CDM|1.3|{"originWidth":1494,"originHeight":836,"style":"alignCenter","width":592,"height":331}_##]

> 본 글은 **마이크로서비스의 분산 추적** 시리즈로 이론과 실습이 함께 포함된 시리즈입니다. 아래 목차에 표시된 글을 모두 참고하면 좋습니다.

### 목차

- [분산 추적이란?](#)
- [Spring Cloud Sleuth 와 Zipkin](#)
- [Sleuth 로 Http 환경의 분산 추적 실습](#)
- [Sleuth 로 Messaging 환경의 분산 추적 실습](#)

---

# Zipkin 에 대해서

Zipkin 은 **트위터**에서 개발하고 사용한 Distributed Tracing Tool 이다

[##_Image|kage@dd7YxJ/btrAV28Ptnk/8KcEphapITxnHnhkMLVhb0/img.png|CDM|1.3|{"originWidth":1934,"originHeight":604,"style":"alignCenter"}_##]

Zipkin 에서는 [지난 시간](#) 에서도 이야기하였던 Dapper 를 이용하여 분산 환경에서 메시지를 추적한다.

Zipkin 에서는 **Tracer** 와 함께해야 한다.

Tracer 는 각 노드에 포함되어있는 애플리케이션 라이브러리 혹은 Sidecar 로 해당 노드에서 발생한 메시지를 **Timing Data 와 같은 Metadata** 를 포함시켜 Zipkin 으로 전송해준다.

그럼 Zipkin 에 포함된 Collector 에 의해서 해당 데이터들이 모이게 되고 정제된다.

그런 뒤 Zipkin 의 UI Dashboard 에서 확인할 수 있게 한다

# Trace 와 Span

Zipkin 에서는 분산 환경의 메시지들을 Trace 와 Span 을 통해서 구분하고 상관관계를 규정한다

[##_Image|kage@bVhp15/btrARqDMqEJ/dPVwu2ryPltBfASNUF2ow1/img.png|CDM|1.3|{"originWidth":1612,"originHeight":412,"style":"alignCenter"}_##]

## Span in Zipkin

Span은 Timing Data 와 같은 메타 데이터를 포함하는 정보이다.

Span 에 포함된 데이터는 계속해서 Zipkin Collector 로 전송되어야 하기 때문에 가능한 작게 유지되어야 한다.

Span 은 서로 연결되어있는데, SpanId 와 ParentSpanId 를 통해서 논리적으로 연결되어있다

## Trace in Zipkin

Trace 는 Span 들의 세트로 **하나의 TraceId** 를 각각의 Span 들이 공유하는 방식이다

이러한 Span 과 Trace 데이터가 Zipkin 에 전송되면 다음과 같은 json 으로 Zipkin

```
  [
    {
      "traceId": "5982fe77008310cc80f1da5e10147517",
      "name": "get",
      "id": "bd7a977555f6b982",
      "localEndpoint": {
        "serviceName": "zipkin-query",
      },
      "annotations": [
        {
          "timestamp": 1458702548467000,
        },
        {
          "timestamp": 1458702548853000,
        }
      ]
    },
    {
      "traceId": "5982fe77008310cc80f1da5e10147517",
      "name": "get-traces",
      "id": "ebf33e1a81dc6f71",
      "parentId": "bd7a977555f6b982",
      "localEndpoint": {
        "serviceName": "zipkin-query",
      },
      "tags": {
        // 생략
      }
    }
  ]
```

# Zipkin 의 아키텍처

[##_Image|kage@ISMzc/btrARMzMZAu/Wpci8zd9WfQx3CQorpXlQK/img.png|CDM|1.3|{"originWidth":1374,"originHeight":1008,"style":"alignCenter","width":568,"height":417}_##]

Zipkin 은 크게 3가지의 파트로 나뉜다.

1. Reporter
2. Collector
3. Storage & UI

## Reporter

- 마이크로서비스 노드에 포함되며 메시지가 발생할 때마다 해당 메시지의 Metadata 를 Zipkin Collector 로 비동기적으로 전송한다
- Metadata 에는 Timing Data, TraceId, SpanId 와 같은 정보들이 포함된다

## Collector

- 마이크로서비스 컴포넌트는 zipkin daemon 으로 데이터를 전송하는데 이 데이터를 받는 모듈을 컬렉터라고 부른다.

## Storage & UI

- 카산드라가 기본적인 Storage Infrastructure 로 사용된다.
- Plug & Play 방식이기 때문에 Cassandra 이외에도 Elastic Search & MySQL 을 연동할 수 있다

# Spring Cloud Sleuth

Zipkin 과 함께 사용되는 Tracer 는 많은 것들이 존재한다.

공식적으로 Zipkin 이 개발하고 운영하는 **Zipkin Supported** 과 Open Source 로 운영되는 **Zipkin Community Supported** 가 있다.

- Zipkin Supported
  - brave
  - zipkin-js
  - zipkin-go
- Zipkin Cummunity Supported
  - spring cloud sleuth
  - tapper
  - appmetrics-zipkin
  - htrace

이 중에서도 우리는 Spring Cloud 프로젝트에서 공식적으로 지원하는 **Spring Cloud Sleuth** 에 대해서 알아볼 것이다.

Spring Cloud Sleuth 는 분산 추적을 위한 Spring Boot 기반의 auth-configuration 을 제공한다.

대표적인 Sleuth 의 기능에 대해 이야기해보자면 다음과 같다

- Header Propagation 을 이용하여 Trace 정보를 기록한다.
- TraceId, SpanId 를 자동으로 생성해준다.
- Http 을 통해서 Tracing 정보를 Zipkin 으로 전송한다
- Trace 에 대한 정보들을 토대로 Log Integration 을 제공한다
