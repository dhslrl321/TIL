- 연관관계 매핑 고려사항 3가지
  1. 다중성 (1:1, 1:N, N:1, N:M)
  2. 단방향, 양방향
  3. 연관관계의 주인

# 다중성

- DB 관점에서 다중성을 고민하면 됨
  - 예를 들어서 회원과 팀이 있다고 했을 때 회원과 팀의 관계가 헷갈린다면 반대로 생각해보면 됨
- 다대일 `ManyToOne`
  - 가장 많이 씀
- 일대다 `OneToMany`
  - 필요할 때 씀
- 일대일
  - 가끔 씀
- 다대다
  - 실무에서 안 씀
  - 쓰면 안됨

# 단방향 양방향

- 테이블
  - 외래 키 하나로 양쪽으로 조인이 가능함
    - 멤버에서 팀을 찾을 수 있고 팀에서도 멤버를 찾을 수 있음
  - 그래서 방향이라는 개념이 없음
- 객체
  - 참조용 필드가 있는 쪽으로만 참조가 가능
    - 멤버에서 팀을 찾으려면 팀이라는 레퍼런스가 존재해야 함
  - 한쪽만 참조하면 단방향
  - 양쪽이 서로 참조하면 양방향
    - 사실상 양방향이 아니라 단방향이 두 개임
- 가급적이면 단방향을 이용할 것

# 다대일

- 가장 많이 사용함
- Member(다)와 Team(1)이 있다고 가정
  - 하나의 팀에는 여러 멤버가 있을 수 있음
    - 다 에 외래 키가 있어야 함
- 단방향
  - 외래 키가 있는, Team 객체가 있는 곳(Member)에서 `@ManyToOne` 를 지정
- 양방향
  - 양쪽을 서로 참조해야 할 때
  - Team 에서 Member 리스트로 관리하게 `List<Member>` 를 추가하고 `@OneToMany(mappedBy = "")`를 추가
    - 해당 문자열에는 `@ManyToOne` 에 있는 참조 변수가 들어감

# 일대다

- Team 입장에서 Member 를 List로 관리할 때
  - 앞선 `@OneToMany(mappedBy = "")` 와 동일
  - 안티 패턴
- 만약 Team 에 members (`List<Member> members`) 에 값이 바뀌었다
  - 그럼 Member 테이블에 insert 쿼리를 날려야 함
  - 이건 관심사 분리가 안된거라고 봐도 무방
  - Team 에 관련된 일을 수행했는데 다른 테이블, Member 테이블에 쿼리가 날아갔기 때문
- `@JoinColumn(name = "")` 을 사용한다.
  - 만약 사용하지 않으면 Join Table 방식을 사용함
    - 새로운 테이블이 생겨버림
- 야매로 읽기 전용 매핑이 가능함
  - `@ManyToOne`과 `@JoinColumn(name = "", insertable = false, updatable = false)` 을 하면 됨
  - 읽기 쓰기가 가능하긴 하는데 최종적으로 트랜잭션이 커밋되어도 insert, update가 이루어지지 않음
  - 그냥 다대일 양방향을 써라

# 일대일

- 일대일 관계는 대칭적
  - 하나의 멤버는 하나의 라커룸을 갖는다.
- 주 테이블이나 대상 테이블 중 외래 키 선택 가능 (db에서)
  - 주 테이블에 외래 키
  - 대상 테이블에 외래 키
  - 대칭적이라 어디에 넣든 상관 없음
    - 멤버에 라커룸 id가 외래 키로 있는 경우
    - 라커룸에 멤버 id가 외래 키로 있는 경우
- 외래 키에 데이터베이스 유니크 제약 조건 추가
- 단방향
  - 주 테이블에 외래 키
    - 주 테이블에서 `@OneToOne`과 `@JoinColumn(name = "")` 추가
    - 대상 테이블에서 `@OneToOne(mappedBy = ""`을 추가
      - mappedBy 에는 주 테이블에 있는 대상 테이블의 참조 변수
  - 대상 테이블에 외래 키
    - 불가능
    - 양방향은 가능
- 양방향
  - 대상 테이블에 외래 키 양방향

# 다대다

- 실무에서 안 씀
- 관계형 DB 에서는 정규화된 테이블 2개를 다대다로 표현 불가
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
  - 연결 테이블, 매핑 테이블
- DB는 안되는데 객체는 가능함
