# Thread

- 경량 프로세스
- 프로세스의 하나의 실행 단위
- 독립적인 Program Counter 를 가짐
- 같은 프로세스에 속한 다른 쓰레드와 코드 등 일부 자원을 공유하지만 모든 자원을 함께 공유하지는 않음
- 하나의 프로세스 하위에 속하며, 쓰레드 하나가 프로세스 하나의 하위에 존재한다면 다른 프로세스에 포함될 수 없음
- 쓰레드를 이용해서 CPU와 Application의 성능을 향상시킴

# Thread 생성

- **방법 1** `Thread` 클래스 상속
  - Thread 를 상속 받으면 다른 클래스를 상속받지 못하므로 재사용성이 비교적 낮음
  - `run()` 메서드 재정의
  - Thread 클래스의 메서드를 직접 호출할 수 있음
- **방법 2** `Runnable` 인터페이스 구현
  - 재사용성이 높음
  - `run()` 메서드 구현
  - 사용하는 곳에서 Thread 의 생성자 파라미터로 Runnable 을 구현한 객체를 넣어줘야 함
  - `currentThread()` 를 호출해서 Thread 에 참조해야함
- **Thread 실행**
  - `start()` 메서드를 이용해서 실행하면 됨
  - 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없음
  - 하나의 쓰레드는 `start()` 가 한 번만 호출될 수 있음
    - 두 번 실행하면 `IllegalThreadStateException` 발생

```java
/* Thread 상속 */
public class ThreadByExtends extends Thread {
  @Override
  public void run() {
    System.out.println("---" + getName() + "---");
  }
}

/* Runnable 인터페이스 구현 */
public class ThreadByImpl implements Runnable {
  @Override
  public void run() {
    Thread thisThread = Thread.currentThread();
    System.out.println("---" + thisThread + "---");
  }
}

/* 사용 방법 */
public class Main {
  public static void main(String[] args) {
    Thread thread1 = new ThreadByExtends(); // 1

    Runnable runnable = new ThreadByImpl(); // 2
    Thread thread2 = new Thread(runnable); // 2

    Thrad thread3 = new Thread(new ThreadByImpl()); // 3

    thread1.start();
    thread2.start();
    thread3.start();
  }
}
```

# Thread vs Run

- Thread의 run 메서드에 내부 로직을 실행하는 방법은 2가지가 있음
  1. `start()`
  2. `run()`
- 쓰레드 하나는 독립된 콜 스택을 가짐
- **start()**
  - 새로운 콜 스택을 생성한 뒤, run() 메서드를 실행시킴
  - 독립된 콜 스택을 새롭게 생성 후 작업이 끝나면 콜 스택을 삭제
- **run()**
  - 쓰레드를 실행시키는 것이 아니라 Thread Class 에 선언된 run 을 호출하는 것
  - run() 을 호출한 콜 스택에 메서드가 올라감
    - 즉, run() 을 호출한 쓰레드의 콜 스택을 공유한다는 의미

# 싱글 쓰레드와 멀티 쓰레드

- 어떤 2개의 작업 (A, B)을 수행하는 로직이 존재한다고 했을 때, 각각 싱글 쓰레드로 했을 때와 멀티 쓰레드로 했을 때의 차이
  - 싱글 쓰레드
    - A 를 끝내고 B를 순차적으로 작업을 끝냄
  - 멀티 쓰레드
    - A왔다가 B 왔다가를 번갈아가며 작업을 끝냄
- 결과는 싱글 쓰레드가 더 빠름
  - 이유는 멀티 쓰레드를 이용한다면 CPU가 프로세스, 쓰레드간 작업 전완인 Context Switching 을 하며 여러 데이터를 교환하고 해석하며 실행하기 때문에
  - 잠재적인 문제 발생 가능성
    - 서로 같은 자원을 공유하여 멀티 코어의 쓰레드로 동작한다면 각각의 코어가 동일한 자원을 점유하기 위해서 경쟁 (Race Condition)하는 일이 발생함
      > Race Condition : 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과 값에 영향을 줄 수 있는 상태
  - 같은 자원을 두고 연산 하는 경우에는 싱글 쓰레드가 빠르고, 각각 집중하는 자원의 영역이 확실한 일, 파일 입출력하고, 콘솔에 출력하는 일 멀티 쓰레드가 빠름
  - 무조건적인 멀티 쓰레드는 좋지 않음

**싱글 쓰레드**

```java
public class Main {
  public static void main(String[] args) {
    for (int i = 0; i < 100; i++) {
        System.out.print("1 ");
    }

    for (int i = 0; i < 100; i++) {
        System.out.print("2 ");
    }
  }
}

public class ThreadByImpl implements Runnable {
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      System.out.print("2");
    }
  }
}

// 출력
11111111111111111111111111111111111111 222222222222222222222222222222222
```

**멀티 쓰레드**

```java
public class Main {
  public static void main(String[] args) {
    Thread thread = new Thread(new ThreadByImpl());

    thread.start();

    for (int i = 0; i < 100; i++) {
        System.out.print("1 ");
    }
  }
}

public class ThreadByImpl implements Runnable {
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      System.out.print("2");
    }
  }
}

// 출력
1111222111111122211111111111111222211111111222222222221222222222111111112
```

# 선점 스케줄링의 우선순위와 쓰레드의 우선순위

- 선점 스케줄링
  - 프로세스가 CPU를 할당 받아 실행 중에도 우선순위가 높은 다른 프로세스가 CPU를 뺴앗을 수 있는 스케줄링 기법
  - 빠른 응답시간을 요구하는 시스템에서 주로 사용
  - CPU의 스케줄링 방법에는 SRT, RR, MLQ, MLFQ 등의 스케줄링 방법이 존재
    - SRT : 남은 시간이 짧은 프로세스부터 처리
    - RR : 먼저 들어온 순서대로 일정 시간만큼만 처리
    - MLQ : 우선순위별로 큐를 분리하여 다양하고 서로 다른 스케줄링 적용
    - MLFQ : MLQ 에서 큐 간 이동하여 우선순위 조정
  - 선점 시간 배당을 위해서 타이머 클럭이 필요하고, 선점으로 인한 많은 오버헤드를 초래함
- 쓰레드와 우선순위
  - 프로세스와 마찬가지로 쓰레드도 스케줄링 정책 및 우선순위를 적용할 수 있음
  - `Thread.setPriority()`, `Thread.getPriority()` 로 쓰레드의 우선순위를 지정하고 확인할 수 있음
  - default 우선순위는 5임
    - `MAX_PRIORITY = 10`
    - `MIN_PRIORITY = 1`
    - `NORM_PRIORITY = 5`
  - 특정 쓰레드에서 새로운 쓰레드를 만들면 쓰레드의 우선순위는 부모 쓰레드의 우선순위를 따라감
  - 싱글 코어 vs 멀티 코어
    - 싱글 코어 : 우선순위에 따라서 차이가 심함
    - 멀티 코어 : 차이가 거의 없음
    - 이로 미루어 보아 알 수 있는 점
      - 하지만 OS 마다 서로 다른 구현의 JVM이 있기 때문에 무조건적으로 우선순위가 높다고 해서 먼저 실행되는 것은 아님
    - 결론
      - 차라리 쓰레드에 우선순위를 부여하는 것 보다 작업에 우선순위를 두어 PriorityQueue 에 저장하고 처리하는 방식이 더 효율적일 수 있음

```java
public class Main {
  public static void main(String[] args) {
    Thread thread1 = new Thread(new ThreadByImpl_1());
    Thread thread2 = new Thread(new ThreadByImpl_2());

    thread1.setPriority(Thread.MAX_PRIORITY);
    thread1.start();
    thread2.start();
  }
}

public class ThreadByImpl_1 implements Runnable {
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      System.out.print("1");
    }
  }
}

public class ThreadByImpl_2 implements Runnable {
  @Override
  public void run() {
    for (int i = 0; i < 100; i++) {
      System.out.print("2");
    }
  }
}

// 싱글 코어 출력 (차이가 확실함)
1111111111111221111111111111111111222222222222222222222222222

// 멀티 코어 출력 (차이가 거의 없음)
1212221121111221212222112121122121212112211221121212221211112
```

# 쓰레드 그룹

- 서로 관련된 쓰레드
