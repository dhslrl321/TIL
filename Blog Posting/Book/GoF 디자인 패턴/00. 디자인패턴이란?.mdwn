# 디자인 패턴

- 건축가이자 패턴의 아버지 *크리스토퍼 알렉산더*이 말 함
  - 똑같은 방법으로 두 번 하지 않고 100만번 이상 재사용할 수 있도록 하라
  - 패턴을 통해서 어떤 상황의 문제를 해결
- 재사용 가능한 객체지향 설계를 만들기 위한 유용한 공통의 설계 구조를 추상화
- 특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스

# 객체 인터페이스 명세

- 시그니쳐
  - 인터페이스가 명세하는 모든 스펙
  - ex) 반환 값, 필드, 매개변수, 메서드
- 인터페이스
  - 객체가 정의한 연산의 모든 시그니처
  - 객체가 받아서 처리할 수 있는 연산
  - 실제 구현이 없음
- 타입
  - 특정 인터페이스를 일컫는 말
- 슈퍼 타입
  - 다른 인터페이스가 해당 인터페이스를 상속
- 서브 타입
  - 다른 인터페이스를 상속
- 동적 바인딩
  - 요청에 대한 객체를 런타임 시에 정하는 것
- 다형성
  - 동적 바인딩이 되기를 기대하는 인터페이스가 하나 이상의 인터페이스와 동적 바인딩 되는 성질
- 클래스
  - 인터페이스를 구현하는 것
- 인스턴스
  - 클래스가 만들어내는 객체
- 서브 클래스
  - 부모 클래스를 상속하는 클래스
  - 부모 클래스가 정의한 모든 데이터를 가짐
  - 오버라이드 가능
  - 부모 클래스가 정의한 행동을 재정의 하거나 정제할 수 있음
- 추상 클래스
  - 서브 클래스 사이의 공통되는 인터페이스를 정의
  - 실제 구현을 서브 클래스에게 넘김
  - 인스턴스 생성 불가

# 상속 vs 합성

- 상속
  - 상속은 부모 클래스에 대한 정보를 서브 클래스가 알게 됨
  - 이를 화이트 박스 재사용아리고 함
    - 부모 클래스의 내부가 서브 클래스에게 공개되기 때문에
  - 장점
    - 서브 클래스에서 부모 클래스의 수정이 쉬움
    - 일부 재정의가 가능
  - 단점
    - 런타임에 상속받은 부모 클래스의 구현 변경 불가
    - 화이트박스의 특성 덕분에 캡슐화를 파괴한다는 주장도 있음
    - 부모 클래스의 구현에 종속됨. 결국 부모 클래스가 바뀌면 서브 클래스도 바뀌어야 함
- 합성
  - 다른 객체 여러 개를 붙여서 새로운 객체를 구성
  - 한 객체가 다른 객체에 대한 참조자를 얻는 형태
  - 객체의 내부가 공개되지 않는 블랙박스라고 함
  - 장점
    - 런타임 시에 동적으로 생성됨
    - 캡슐화 유지가 가능
  - 단점
    - 인터페이스 정의에 더욱 신경써야 함

#### 결론 : 상속 보다는 단점을 더 많이 사용한다. 이유는 캡슐화로 독립성이 높아지기 때문에

# 위임

- 멤버 변수로 다른 객체를 정의하고 특정 작업을 해당 객체로 위임
- 두 객체가 하나의 요청을 처리하는 형태
- 위임을 이용한다면 런타임에 행동의 복합을 가능하게 함
- 디자인 패턴에서 위임은 자주 사용됨
- 단점
  - 고도로 매개변수화 되어 어려운 설계 기법이 될 수 있음

# 상속 vs 제네릭

- 제네릭
  - 기능의 재사용에 이용할 수 있는 상속과 다른 방법
  -
