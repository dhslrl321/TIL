# 연결 리스트

우리는 앞에서 [스택 자료구조]()와 [큐 자료구조]()에 대해서 알아보고 직접 **구현**해보면서 문제점들을 하나씩 파악했다.
두 자료구조 모두 **배열**을 이용했었는데, 이런 배열을 사용하면 **크기가 고정**된다는 아주 치명적인 단점이 존재했었다.
그에 반해서 **연결 리스트**는 다음과 같은 장점이 존재한다.
이것들 외에 또 **하나의 특징이 더 존재**한다.
스택과 큐에는 어떤 제약 사항이 있었을까?
바로 **항목에 대한 접근 방법이다.**
스택은 front로만 접근이 가능했고 큐는 rear와 front로만 접근할 수 있었다.
하지만 연결 리스트는 이런 제약 사항에 대해서 매우 자유로우며 front, rear은 물론이며 중간 항목에 접근하며 삭제 추가 이동을 할 수 있다.

그래서 장점을 한 번 나열해보면 이렇다.

#### 장점

- 배열(리스트)의 크기가 동적으로 변할 수 있다.
- 메모리상 연속적인 공간에 할당되지 않는다.
- 미리 공간을 할당하지 않아도 된다.
- 중간에 값을 자유롭게 을 삭제, 추가할 수 있다.

그렇지만 다음과 같은 단점을도 존재한다.

#### 단점

- 링크 필드를 위한 추가 공간이 필요하다.
- 연산의 구현이나 사용방법이 배열에 비해 복잡하다.

스택이나 큐에 원형 큐, 데크와 같이 다양한 종류가 있었듯 연결 리스트도 크게 3가지 종류가 존재한다.

#### 연결 리스트의 3가지 종류

1. 단순 연결 리스트 (Singly Linked List)
2. 원형 연결 리스트 (Circular Linked List)
3. 이중 연결 리스트 (Doubly Linked List)

이렇게는 사용하는 용도에 따라서 3가지로 나뉠 수 있다.
**단순 연결 리스트**와 **이중 연결 리스트**는 마지막 노드가 Null을 가리키지만 **원형 연결 리스트**는 마지막 노드가 첫번째 노드를 가리킨다.

이는 더욱 자세하게 다음 시간에 알아보기로 하고, 우선 리스트를 가볍게 구현해보자.

# 연결 리스트의 구조

일반적인 연결 리스트는 2가지로 구성되어있다.

- 노드 : 사실상 연결 리스트의 핵심이라고 해도 과언이 아니다. 연결 리스트는 **노드들의 집합**으로 데이터를 저장하며 서로 연결되어있다. 노드는 또 2가지로 나뉜다.
  - 데이터 필드 : 데이터가 실질적으로 저장된 부분
  - 링크 필드 : 다음 혹은 다른 노드를 가리키는 **노드의 주소를 저장**하는 포인터 변수
- 헤드 포인터 : 연결 리스트는 **첫 번쨰 노드만 알면** 모든 노드에 접근할 수 있다. 따라서 이 헤드 포인트에서 **첫 번째 노드의 주소**를 저장한다.
