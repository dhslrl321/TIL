# BDD

- **TDD와 BDD**
  - TDD
    - TDD 란?
    - TDD 예제
    - TDD 동영상 추천 및 책 추천
  - BDD
    - BDD 란?
      - 애플리케이션이 어떻게 **행동**해야 하는지에 대한 공통된 이해를 구성하는 방법으로 TDD에서 착안
    - BDD 예제
    - BDD 동영상 추천
- **TDD BDD 차이**
  - TDD
    - 켄트 벡이 창시한 코드 구현 방법론
    - 애자일을 실현하는 중요한 도구로서 사용됨
    - 시나리오 기반
  - BDD
    - 행동 기반
    - 더 자연어와 가깝게
- **BDD 더 깊게**
  - BDD의 역사
    - Danial Terhorst-North와 Charis Matts가 착안 [BDD Introducing - Dan north & associates](https://dannorth.net/introducing-bdd/)
      - TDD를 하다가 해당 코드를 분석하기 위해서 많은 코드들을 분석해야하고 복잡성으로 인해 '누군가가 나에게 이 코드는 어떤식으로 짜여졌어! 라고 말을 해줬으면 좋았을 텐데' 라는 생각을 하다가 보니 행동 중심 개발을 하면 좋겠다고 생각함
    - TDD의 행동 중심의 개발
  - BDD 행동에 대한 스펙
    - Narrative
    - Acceptance Criteria
      - Given / When / Then : 어떤 상태에서 출발하여 어떤 상태의 변화를 가했을 때 기대하는 어떠한 상태가 되어야 한다.
- **Mockito 에서 BDD 사용하기, BDDMockito**

해당 글은 BBDMockito 와 관련하여 여러 파트로 나뉘어져 있으니 각각을 참고하시기 바랍니다.

- Part 1. [JUnit5 BDDMockito로 알아보는 TDD와 BDD 의 차이]()
- Part 2. [BBDMockito의 given() 메서드와 사용법]()
- Part 3. [BBDMockito의 should() 메서드와 사용법]()

### 목차

- TDD 란?
  - TDD 란?
  - TDD 예제
- BDD 란?
  - BDD 란?
  - BDD 예제
- TDD vs BDD
  - TDD와 BDD의 한 표 요약
- BDDMockito를 이용한 BDD
  - 실습 환경 구성
  - Mockito vs BDD Mockito
  - Stubbing
- BBDMockito - given()
- BBDMockito - given()
- BBDMockito - given()

본 주제를 학습하기 위해서는 Java와 **JUnit5와 BDDMockito 라이브러리**의 의존성이 필요합니다.

---

소프트웨어를 개발하면서 지금까지 느낀 가장 큰 변화가 나에게는 TDD가 아닐까 싶다.

우연한 기회에 TDD를 스스로 도입하였을 때, 내가 들었던 첫 생각은

> 너무 귀찮은데,... 이렇게 하다가 언제 끝내지...? 이거 그냥 테스트 안 짜고 바로 할 수 있는데..

이런 생각을 갖고 TDD를 _증오_ 하던 시간이 얼마 지나지 않아서 실타래처럼 꼬인 아주 모호한 기능(Spring Security 에서) 구현해야할 때가 있었다.  
늘 그렇듯 TDD로 실패하는 코드를 먼저 짜고 **내가 뭘 해야할지를 적어가면서** 하나씩 테스트를 수행하고 기능을 고치면서 점점 실타래가 풀리는 것 같은 기분이 들게 되었다.

그리고 하나 하나 기능을 추가하며 최고로 복잡하던 그 기능을 하나씩 풀어가며 느꼈던 감정은 **증오에서 맹신**으로 바뀌게 된 계기 같았다.

이렇듯 TDD는 여러 개발자에게 좋은 개발 습관을 갖게 할 수 있는 방법 중 단연 최고라고 생각한다.  
오늘은 TDD에서 조금 더 진화한 BDD에 대해서 알아보려 한다.

그 전에 TDD와 BDD에 대한 용어 정리를 해보자.

# **TDD**, Test Driven Development

[##_Image|kage@b7fli0/btq3dPvzKQW/7PBciWtxFaWaJzK6wGaIc1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="659" height="NaN" data-ke-mobilestyle="widthContent"|||_##]

TDD는 Test Driven Development으로 **테스트가 개발을 주도한다**는 개념으로 사용된다.

TDD는 **테스트를 먼저 만들고 테스트를 통과하기 위한 행동**들이 모두 개발을 주도하는 것을 목표로 한다.  
보통 테스트는 개발이 끝난 후에 하는 과정이라고 생각할 수 있다.  
하지만 TDD는 개발 중간 중간에 끊임 없는 테스트를 통해 기능을 개발해야 한다.

TDD는 **Kent Beck**이 고안해낸 방법론으로 이 책은 하나의 바이블로 여러 개발자들에게 주목받고 있는듯 하다.

[##_Image|kage@bbC0ZW/btq3cb0blp0/FXjh8YImTVKu4o7Ln7uPw0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="348" height="NaN" data-ke-mobilestyle="widthContent"|||_##]

> TDD를 번역한 한글판 책이 있는데, 혹시 이에 대한 정보가 궁금하다면 해당 블로그에 있는 **개발자 책 읽기** 의 [테스트 주도 개발 - Kent Beck](https://wonit.tistory.com/category/%F0%9F%93%97%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EC%B1%85%20%EC%9D%BD%EA%B8%B0/-%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C) 을 확인해 보는 것도 좋은 방법인 것 같다.

## TDD 예제

계산기를 TDD로 구현해보자면 다음과 같다.

### Step 1. 우선 비어있는 Calculator 클래스와 CalculatorTest 클래스를 생성하자.

```
public class Calculator {

}

public class CalculatorTest {
    Calculaotr calc = new Calculator();
}
```

간단하게 테스트 코드에 `Calculator` 클래스의 인스턴스를 생성해주자.

### Step 2. 내가 원하는 기능(덧셈, `plus()`)이 어떻게 생겼고 뭘 반환하는지 CalculatorTest 에 작성한다.

```
public class Calculator {

}

public class CalculatorTest {
    Calculaotr calc = new Calculator();

    @Test
    void plus() {
        int a = 10;
        int b = 20;
        int result = calc.plus(a, b);
    }

}
```

현재 `Calculator` 클래스에는 plus라는 메서드가 존재하지 않기 때문에 **실패**하게 된다.

### Step 3. Calculator 클래스에 해당 메서드를 통과할 수 있는 간단한 클래스를 구현한다.

```
public class Calculator {
    public int plus(int a, int b) {
        return 0;
    };
}

public class CalculatorTest {
    Calculaotr calc = new Calculator();

    @Test
    void plus() {
        int a = 10;
        int b = 20;
        int result = calc.plus(a, b);
    }
}
```

Calculator의 plus 메서드에서는 어떤 값이 반환되도 좋다.  
그냥 일단 컴파일을 성공시키는 것이 목적이다.

### Step 4. Calculator 클래스에서 어떤 결과를 내어야 할지 CalculatorTest 클래스에서 다시 정의한다.

```
public class Calculator {
    public int plus(int a, int b) {
        return 0;
    };
}

public class CalculatorTest {
    Calculaotr calc = new Calculator();

    @Test
    void plus() {
        int a = 10;
        int b = 20;
        int result = calc.plus(a, b);

        assertEquals(result, a + b);
    }
}
```

`assertEquals` 는 JUnit 5에 존재하는 검증문으로 매개변수 2개가 서로 동일하면 테스트 성공을 의미한다.

현재 result 에서는 0을 반환하니 해당 테스트는 또 실패할 것이다.

### Step 5. Calculator 클래스에서 해당 테스트를 통과할 수 있는 로직을 구현한다.

```
public class Calculator {
    public int plus(int a, int b) {
        return a + b;
    };
}

public class CalculatorTest {
    Calculaotr calc = new Calculator();

    @Test
    void plus() {
        int a = 10;
        int b = 20;
        int result = calc.plus(a, b);

        assertEquals(result, a + b);
    }
}
```

# **BDD**, Behavior Driven Development

BDD는 전혀 새로운 방법이 아니다.

Danial Terhorst-North와 Charis Matts가 착안 [BDD Introducing - Dan north & associates](https://dannorth.net/introducing-bdd/)안 방법론으로 **BDD의 모든 근간은 TDD**에서 착안되었기 때문에 TDD가 추구하는 가치와 크게 다르지 않다.

[##_Image|kage@bDCXms/btq3gjpHufE/PJteGo9PBMHYudkWYer9E1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="526" height="NaN" data-ke-mobilestyle="widthContent"|||_##]

Danial Terhorst-North가 처음으로 BDD를 생각해 낸 때는 바로 TDD를 수행하고 있던 도중이었다고 한다.

> The deeper I got into TDD, the more I felt that my own journey had been less of a wax-on, wax-off process of gradual mastery than a series of blind alleys. I remember thinking “If only someone had told me that!” far more often than I thought “Wow, a door has opened.” I decided it must be possible to present TDD in a way that gets straight to the good stuff and avoids all the pitfalls.

> My response is behaviour-driven development (BDD). It has evolved out of established agile practices and is designed to make them more accessible and effective for teams new to agile software delivery. Over time, BDD has grown to encompass the wider picture of agile analysis and automated acceptance testing

이 말을 간단하게 하자면 **TDD를 하다가 해당 코드를 분석하기 위해서 많은 코드들을 분석해야하고 복잡성으로 인해 '누군가가 나에게 이 코드는 어떤식으로 짜여졌어! 라고 말을 해줬으면 좋았을 텐데' 라는 생각을 하다가 보니 행동 중심 개발을 하면 좋겠다고 생각했다.**

BDD는 행동에 기반하여 TDD를 수행하자는 공통의 이해인데, 이를 한 문장으로 말 하자면 다음과 같다.

#### BDD는 애플리케이션이 어떻게 **행동**해야 하는지에 대한 **공통된 이해**를 구성하는 방법이다.

## BDD의 행동

BDD 에서는 행동에 대한 스펙은 다음과 같다.

1.  Narrative
2.  Given / When / Then

#### 모든 테스트 문장은 Narrative 하게 되어야 한다. 즉, 코드보다 인간의 언어와 유사하게 구성되어야 한다.

TDD 에서는 사실상 테스트 코드를 이용한 **구현에 초점**이 맞춰저 있다.

하지만 BDD는 그렇지 않다.

**BDD는 TDD를 수행하려는 어떠한 행동과 기능을 개발자가 더 이해하기 쉽게**하는 것이 목적이다.

#### 모든 테스트 문장은 Given / When / Then 으로 나눠서 작성할 수 있어야 한다.

위에서 말 한 Narrative를 수행하기 위한 실질적인 개념이라고 생각하면 될 것 같다.

- Given
  - **테스트를 위해 주어진 상태**
  - **테스트 대상에게 주어진 조건**
  - **테스트가 동작하기 위해 주어진 환경**
- When
  - **테스트 대상에게 가해진 어떠한 상태**
  - **테스트 대상에게 주어진 어떠한 조건**
  - **테스트 대상의 상태를 변경시키기 위한 환경**
- Then
  - **앞선 과정의 결과**

### 즉, 어떤 상태에서 **출발 (given)** 하여 어떤 상태의 **변화를 가했을 때 (when)** 기대하는 어떠한 상태가 **되어야 한다.(then)**

## BDD 예제

앞선 상황에서 TDD의 흐름을 빼고 BDD의 핵심 개념인 행동에 따른 Given When Then 을 도입하면 다음과 같다.

```
public class Calculator {
    public int plus(int a, int b) {
        return a + b;
    };
}

public class CalculatorTest {
    Calculaotr calc = new Calculator();

    @Test
    void plus() {
        // given
        int a = 10;
        int b = 20;

        // when
        int result = calc.plus(a, b);

        // then
        assertEquals(result, a + b);
    }
}
```

큰 차이가 없지 않나?

#### 당연한 것이다. BDD 자체가 TDD에서 더 새로운 개념이 아니라 TDD를 더 잘, 더 멋지게, 더 협조적으로 사용하기 위한 방법이기 때문이다.

# TDD vs BDD

앞서 말 했지만 TDD와 BDD를 비교한다는 것은 약간 다른 주제의 이야기라 비교 한다는 것이 힘들것 같지만 개인적으로 비교를 해보자면 다음과 같은 표가 나올 것 같다.

<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-style="style15"><tbody><tr><td style="width: 20%; text-align: center;"><b>이름</b></td><td style="width: 20%; text-align: center;"><b>창시자</b></td><td style="width: 20%; text-align: center;"><b>Based</b></td><td style="width: 20%; text-align: center;"><b>핵심</b></td><td style="width: 20%; text-align: center;"><b>라이브러리</b></td></tr><tr><td style="width: 20%; text-align: center;"><b>TDD</b></td><td style="width: 20%;">Kent-Beck</td><td style="width: 20%;">시나리오 기반</td><td style="width: 20%;">테스트가 주도하는 개발</td><td style="width: 20%;">JUnit5, Mockito</td></tr><tr><td style="width: 20%; text-align: center;"><b>BDD</b></td><td style="width: 20%;"><span>Dan North</span></td><td style="width: 20%;">행동 기반</td><td style="width: 20%;">자연어와 더 가깝게 TDD</td><td style="width: 20%;">JUnit5, BDDMockito</td></tr></tbody></table>

# BDDMockito를 이용한 BDD

BDD를 실현하기 위해서는 Given / When / Then 구조를 잘 사용해야 한다.

앞선 방법처럼 **주석을 이용하여 구분**하는 것도 BDD이지만 이보다 더 BDD 스럽게 BDD를 실천할 수 있는 방법이 바로 **BDDMockito**를 사용하는 것이다.

> BDDMockito란 Mockito 라이브러리 내에 존재하는 BDDMockito 클래스를 말 하며 BDD 지향적인 개발을 mockito 에서 api 형태로 제공한다.

## 실습 환경 구성, Dependencies

Springboot 프로젝트를 생성하면 자동으로 JUnit-jupiter 의존성이 추가되는데 해당 의존성이 추가되며 함께 mockito 라이브러리가 추가된다.

[##_Image|kage@ERixH/btq3bVJ8pg3/ggFS24g330IX2y0ckNlMVk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="581" height="NaN" data-ke-mobilestyle="widthContent"|||_##]

**maven**

```
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-all</artifactId>
    <version>1.10.19</version>
    <scope>test</scope>
</dependency>
```

**gradle**

```
testImplementation group: 'org.mockito', name: 'mockito-all', version: '1.10.19'
```

## Mockito vs BDDMockito

순수 Mockito에서 BDD의 Given / When / Then 을 위해서 다음과 같이 `when(obj)` 메서드와 `thenReturn()` 이용하고 `verity()` 구문을 이용해 검증한다.

이런식으로 특정 상황에 대한 (when과 같이) 우리가 가짜로 결과를 만들어 주는 것을 Stubbing(스터빙) 이라고 한다. 즉 **가짜로 수행할 객체를 넣어주는 것**이다.

```
when(phoneBookRepository.contains(momContactName))
  .thenReturn(false);

phoneBookService.register(momContactName, momPhoneNumber);

verify(phoneBookRepository)
  .insert(momContactName, momPhoneNumber);
```

이게 **일련의 BDD의 Stubbing 과정**인데, 뭔가 맞지 않는 부분이 있다.

- when()
- thenReturn()
- verity()

위에 존재하는 3가지 행동 과정인데, 뭔가 이상하다.

개념적으로 given 에 해당되는 Mockito의 `when(phoneBookRepository.contains(momContactName))`의 이름이 when이라 쉽게 햇갈릴 수 있게 되어있다.

#### 이러한 문제점을 BDDMockito의 given() 메서드를 이용해서 해결할 수 있다.

BBDMockito를 이용하면 Mockito의 `when()` 을 `given()` 이라는 메서드로 **더 정확한 의미 전달**을 할 수 있다.

```
given(someClass.method()).willReturn()
```

# given() 메서드

[##_Image|kage@tiKeC/btq3i8tVcZJ/kQK4TUAyPKc478U65pEtBk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]

우선 given() 메서드는 **BDD의 givne**을 그대로 내포하고 있다.

이런 givne()의 파라미터를 이용해서 어떤 상황에 즉, 어떤 메서드가 실행되었을 때의 **테스트를 위한 상황을 설정**할 수 있다.

다음과 같은 상황의 메서드가 있다고 가정해보자.

```
public interface MemberRepository extends JpaRepository<Member, Long> {
    boolean existsByEmail(String email);
}

public class MemberService {
    @Autowired
    private MemberRepository memberRepository;

    public boolean isExistEmail(String email) {
        return memberRepository.existsByEmail(email); // 존재하면 true, 존재하지 않으면 false 반환
    }
}
```

그럼 아래와 같이 테스트 코드를 구성할 수 있다.

```
public interface MemberRepository extends JpaRepository<Member, Long> {
    boolean existsByEmail(String email);
}

public class MemberService {
    @Autowired
    private MemberRepository memberRepository;

    public boolean isExistEmail(String email) {
        return memberRepository.existsByEmail(email); // 존재하면 true, 존재하지 않으면 false 반환
    }
}

public class MemberServiceTest {
    @BeforeEach
    void stubbing() {

    }
}
```
