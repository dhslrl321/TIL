# 애플리케이션 아키텍처와 객체지향

- **아키텍처 란?**
  - 프로젝트에 참여하는 개발자들이 설계에 대해 공유하는 이해를 반영하는 과정
  - A라는 기능과 B라는 기능이 있을 때, 공유하고 싶어하는 부분을 모아서 공유
  - 주관적임
  - 변경하기 어려움
  - 일찍, 올바르게 결정해야 함
- **관심사**
  - 책임
  - 레이어드 아키텍쳐
    - 유사한 관심사를 레이어로 나눠서 수직적으로 배열함
    - 유연하고 재사용이 높아짐
    - 3 가지 레이어가 존재
      - Presentation : 화면, 조작, 사용자의 입력을 모아놓은 레이어
      - Domain : 비즈니스와 관련된 도메인 _가장 중요_
      - Data Source
- **도메인 레이어를 설계하는 방법**
  - 절차 지향 vs 객체 지향
    - Transaction Script Pattern vs Domain Model Pattern
    - 우리나라 대부분의 코드는 객체 지향 언어를 씀에도 불구하고 절차 지향적으로 감
    - 하지만 우리는 Domain Model 을 지향해야 함
- **영화 예메 도메인**
  - `Movie` : 영화
  - `Showing` : 상영
  - `Discount` : 할인 정책
    - `AmountDiscount` : 특정한 절대 금액을 빼줌
    - `PercentDiscount` : 퍼센트로 비율을 빼줌
  - `Rule` : 할인 규칙
    - `SequenceRule` : 조조 상영인 경우
    - `TimeRule` : 어느 시간대에 상영하는 영화
  - `MOVIE 1 - 0..1 DISCOUNT 1 - 1 .. *`

# 절차적 vs 객체 지향

- Transaction Script, 절차적 방식

```java
public Reservation reserveShowing(int customerId, int showingId, int audienceCount) {
  // 1. DB로 movie, showing, rule 조회

  // 2. showing 적용가능한 Rule 조회

  // 3. 조건식으로 Rule 에 걸리는 Discount 조회

  // 4. Reservation 생성 후 DB 저장
}
```

- 서비스 안에 굉장히 많은 내용을 넣음
- 과연 이건 객체 지향일까?
  - 절차적이다.
- 그럼 절차적인 코드가 나쁜 코드일까?
  - 아니다.
  - 특정한 경우에서는 절차적인 코드가 유리하다.
  - 근데 도메인 모델이 복잡해지면 절차적 코드가 불리해진다.
- 어떻게 절차적 코드인지 알 수 있나?
  - 시퀀스 다이어그램을 그렸을 때 하나의 서비스에 다 몰려있으면 절자적 코드라고 함

# 도메인 모델, 객체 지향

- 프로세스와 데이터를 하나의 데이터로 생각
  - 주로 도메인 설계에서 두각을 나타냄
- 객체지향 : 협력하는 객체들의 공동체
  - _핵심은 협력인듯_
  - 객체들이 어떻게 협력하고 상호작용할지를 생각하는게 핵심
  - 모든 객체는 협력을 통해서 메세지를 보내며 동작해야함
- CRC 카드
  - 객체지향 설계 도구
  - 책입과 협력을 표현
  - 객체들이 어떻게 상호작용 하는지를 파악
  - _더 알아볼 것_
- 책임 할당
  - 어떤 행동에 대해서 가장 많이 알고 있는 애, 가장 많은 데이터를 갖고있는 애, 가장 많은 이용? 책임이 있는 애한테 할당하면 됨
  - _우리가 어떤시스템을 만들건데, 이러이러한 객체가 필요하고 이러이러한 연산이 필요해!로 접근하는게 아니고 어떠한 요구사항을 수행하기에 가장 적절한 객체가 뭐가 있을까로 접근해야함_
- 객체지향적응로 짜는 것은
  - 하나의 메서드에 다 넣는게 아니라 필요한 책임에 맞는 객체를 호출하면서 상호작용
- 객체의 구조는 우리가 설계한 DB 테이블 관계와 비슷하게 클래스를 구현해야 함
  - 책임을 적절하게 위임해야 함

# 도메인 레이어와 아키텍처

- 아키텍처의 관점에서 보자
- 도메인 로직 + 애플리케이션 로직이 존재
- **애플리케이션 로직이 존재**
  - 해당 도메인 로직을 수행하기 위한, 혹은 수행한 후의 전후 관계
  - 애플리케이션 로직은 다음과 같은 제약이 있음
    - 도메인 객체 안에 넣지 않고 따로 빼야함
    - 만약 도메인 객체 안에 넣으면 의존성이 생겨버림
    - 결국 결합도가 높아지고 응집도가 떨어짐
- **도메인 레이어는 캡슐화를 해야함**
  - 애플리케이션을 따로 빼는 이유는 결국 캡슐화임
  - 결국 필요한 것은 서비스 레이어임
- **전에 봤던 3가지 아키텍처 레이어에서 서비스 레이어가 추가됨**
  - Presentation : 화면, 조작, 사용자의 입력을 모아놓은 레이어
  - Service : 어플리케이션 로직을 처리, 도메인 로직의 재사용성 촉진
  - Domain : 비즈니스와 관련된 도메인 _가장 중요_
  - Data Source

# 뭘 쓸거냐

- Transaction Model vs Domain Model
- Transaction Model
  - 문제점
  - 기존의 코드를 수정해야한다는 두려움
  - 암묵적인 개념
    - 중복 할인이라는 개념은 개발자만 알고 있음
    - 코드상에서는 중복 할인이라는 것을 찾기 위해서 코드 흐름을 다 따라가야 함
- Domain Model
  - 컴포지트 패턴을 이용하면 됨
  - 기존 코드의 변경이 닫힌 상태에서 새로운 코드가 추가됨
    - OCP 원칙 개방 폐쇠
  - 복잡하다? 요구사항이 자주 변경된다? 객체지향을 쓰면 됨
  - 복잡성을 객체와 객체간의 관계로 풀어가는게 객체지향의 장점임
  - 요구사항이 자주 들어올지 안 들어올지 모르니까 깔끔하게 계속 짜야한다.
