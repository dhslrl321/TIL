[학습 테스트로 배워보는 kafka] 7. 학습 테스트로 partitioning 알아보기

지난시간 우리는 Producer 와 Consumer 의 java client 의 기본적인 내용에 대해서 학습 테스트를 통해 알아보았다.

이번 시간에는 Partition 에 대해서 알아보도록 하겠다

# partitioning

일반적인 데이터 처리의 파티셔닝은 **데이터를 특정 기준에 따라 나누는 것**을 의미한다.

이렇게 나뉜 여러개의 덩어리들을 독립적으로 처리해서 데이터 처리 자체를 **병렬로 만들거나** 검색이 용이하도록 만든다.

카프카에서도 동일하다

카프카는 **토픽별로 파티셔닝**을 지원한다

토픽 내의 데이터를 하나 혹은 그 이상의 파티션으로 나누어 이벤트 로그들을 관리한다

[##_Image|kage@dF6Rkp/btsrB4vvYBL/FQzFKdQU2eNUOkPu6TSE0k/img.png|CDM|1.3|{"originWidth":3274,"originHeight":995,"style":"alignCenter","width":3069,"height":933}_##]

카프카는 이렇게 하나의 토픽을 여러개의 파티션으로 나눠서 **데이터 분산 저장**과 **병렬 처리가 가능하도록** 한다

## 왜 파티셔닝을 하는가?

데이터 처리의 개념에서 파티셔닝이나 카프카의 파티셔닝이나 결국 **데이터를 더 빨리 처리하고자 하는 니즈**에 의해 생겨났다.

만약 한개의 메시지를 발행하고 내부적으로 그 메시지를 처리하는데 1초가 걸린다고 해보자.

그럼 6개의 메시지를 발행하는데 총 6초가 걸릴 것이다

[##_Image|kage@bfMgd9/btsrDJjRWqp/QwXtyeeX7pj8NQ6gqUURtk/img.png|CDM|1.3|{"originWidth":1198,"originHeight":492,"style":"alignCenter","width":1122,"height":461}_##]

하지만 6개의 메시지를 3개의 파티션에 저장해야 한다면 너무나도 당연하게 2초로 시간이 단축되는 컨셉이다

[##_Image|kage@bTVD0v/btsrBnB54GH/fdHoroyuEVxzGLWbqlnYbK/img.png|CDM|1.3|{"originWidth":1198,"originHeight":571,"style":"alignCenter","width":1122,"height":535}_##]

토픽이 여러개의 파티션으로 나뉘면 이제 자연스럽게 **메시지를 어떤 파티션에 보내야 하지?** 혹은 **토픽을 구독하는거야? 파티션을 구독하는거야?** 이라는 주제로 고민을 시작해야 한다.

# 카프카의 파티션 할당

우리가 카프카 프로듀서 api 를 이용하여 카프카 브로커에 메시지(이벤트 로그)를 발행한다고 했을 때, 카프카 내부적으로는 해당하는 메시지를 어떤 파티션에 저장해야 하는가? 에 대한 partition assign 과정을 거치게 된다.

[##_Image|kage@LPBg3/btsrTpssZpt/bG8UUimXKkcwZKaN3mXHF0/img.png|CDM|1.3|{"originWidth":1180,"originHeight":661,"style":"alignCenter","width":1106,"height":620}_##]

위 그림을 보면 알 수 있듯 카프카는 내부적으로 Partitiner 가 이벤트 로그(메시지)들을 어떤 파티션에 할당할지 결정하는 역할을 수행한다

파티셔너는 크게 2가지 파티션 할당 기법을 제공하는데, 다음과 같다

1. key based partitioning
2. Round Robin Partitioning

이 2가지에 대해서 알아보자

# Key Based Partitioning

key based partition 은 우리가 메시지를 발행할 때 특정 키를 입력하여 **해당 키를 hashing 한 값으로 파티션을 결정하는 방법**이다.

## 테스트 1. 키를 이용한 파티션 Produce 테스트

[##_Image|kage@kAHoM/btsrDcmiPcn/CGqRGfuA2xLkN6OV4w7L60/img.png|CDM|1.3|{"originWidth":2136,"originHeight":1572,"style":"alignCenter"}_##]

### 테스트 설명

- 주석 1 & 2
  - for loop 을 돌면서 i 가 짝수/홀수에 따라 파티션 키를 각각 만들었다.
- 주석 3.
  - ProduceRecord 에 이벤트 로그를 partitionKey 와 value 형태로 생성한다
  - 앞서 producer 에서 학습했던 것 처럼 결과를 출력하는 callback 을 추가해주었다
- 주석 4.
  - 콘솔 결과 출력을 위해 blocking 한다

테스트를 실행시키면 다음과 같은 결과가 나온다

[##_Image|kage@dCrcWJ/btsr0YfYUpg/XGyyo2up5ZYHWtlFfATr51/img.png|CDM|1.3|{"originWidth":3102,"originHeight":606,"style":"alignCenter"}_##]

결를 보면 알 수 있듯이 짝수/홀수에 따라 파티션 키가 할당되어 각각의 파티션에 이벤트 로그가 들어간 것을 확인할 수 있다

# 2. Round Robin Partitioning

메시지(이벤트 로그)에 키를 명시하지 않았다면 메시지는 토픽 내의 파티션에 균등하게 RR 방식으로 메시지들이 assign 된다.

## 테스트 2. 라운드 로빈 파티션 Produce 테스트

참조

- [https://devocean.sk.com/blog/techBoardDetail.do?ID=164096](https://devocean.sk.com/blog/techBoardDetail.do?ID=164096)
