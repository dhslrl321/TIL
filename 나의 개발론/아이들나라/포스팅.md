들어가며

최근 아이들나라는 앱스토어나 구글 플레이스토어에서만 구매가 가능했던 구독형 VOD OTT 상품을 웹에서도 결제가 가능하게 함으로써 사용자들에게 더 합리적인 가격으로 서비스를 제공할 수 있도록 하는 프로젝트가 진행되었는데요

지난 2023년 5월 대망의 웹 구독 서비스가 오픈을 하게 되었습니다. (아이들나라 첫달 무료로 구독 시작하기)

이처럼 아이들나라 엔지니어링 팀은 고객이 원하는 기능을 제때 전달하기는 것과 더불어 아래의 것들에도 집중을 하고 있습니다.

시스템 내에서 중요한 역할을 수행하는 레거시 시스템과의 통합

제어하기 힘든 외부 의존 시스템의 내재화 혹은 의존성 제거

아이들나라를 이용하는 소중한 고객분들의 불편함을 줄여나가고 새로운 기능을 가능한 빠르게 전달할 수 있게 되는 것입니다.

이번 글에서는 아이들나라 회원/구독/상품 팀이 subscription 프로젝트를 진행하며 시도했던 의존성의 제어 방법들을 소개하려 합니다

의존성이란?

소프트웨어 시스템에서는 의존성 dependency 은 중요한 키워드 중 하나입니다.

우리는 결국 하나의 완성된 소프트웨어를 개발하기 위해서는 여러 소프트웨어 혹은 기술에 대해 의존하게 됩니다.

가령 우리가 웹 애플리케이션을 개발하기 위해서 Spring 이라는 프레임워크에 의존하여 여러 기술들을 학습하고 실무에 적용하게 되죠.

이러한 의존성은 우리가 작성하는 소스 코드에서 발견될 수 있고, 실행되는 도중에 연산에 의해 발견될수도 있으며 눈에 보이지 않지만 여러 복잡한 관계에 의해 논리적으로 의존하게 될 수도 있습니다.

코드레벨에서 일반적으로 의존성은 다음과 같이 표현됩니다

위 그림을 통해 알 수 있듯이 우리는 X 라는 컴포넌트가 Y 에 의존하고 있다고 이야기합니다.

이 말은 다시 말하자면 Y 가 변경될 때 X 도 그 변경에 대한 영향을 함께 받게 되는 것이지요.

만약 X 를 A, B, C 라는 컴포넌트가 의존한다고 가정해보겠습니다.

그럼 Y 에 변경에 따라 X 가 변경되고, X 의 변경에 따라 A, B, C 가 변경되는 마치 도미노 게임에서 선두에 있는 도미노가 쓰러지는 광경을 목격할 수 있습니다.

여기서 의존성에 대한 중요한 키워드가 존재합니다. 바로 변경에 대한 영향입니다.

의존성은 우리의 소프트웨어 개발에서 없어서는 안되지만 그만큼 잘 제어해야 쉽게 깨지지 않고 신뢰할 수 있는 소프트웨어가 탄생하게 되는 것입니다.

아이들나라 구독 시스템은 이러한 의존성을 제어하기 위해 크게 3가지의 접근법을 제안합니다

경계 만들기

번역하기

레거시 통합하기

하나씩 사례와 코드를 통해 알아보도록 하겠습니다.

1. 경계 만들기

첫번째로 제안하는 방법은 바로 경계 만들기 입니다.

첫째로 의존성을 잘 제어하기 위해서는 경계를 잘 설정해야 합니다.

MVC 나 MVVN, Present & Container 그리고 layered architecture 나 hexagonal architecture 도 모두 경계를 설정하기 위한 다양한 방법들입니다.

위의 방법은 코드 레벨에서 경계를 나누는 것이고 이 개념을 아키텍처로 그대로 확장하기만 하면 됩니다.

아키텍처 기술을 의존성 관점에서 본다면 모두 각각의 모듈 혹은 레이어가 관리하기에 충분히 작은 책임만을 갖고 그 책임에 주어진 역할을 충실하게 책임지게 됩니다.

경계는 서비스의 규모와 방향에 따라서 하나의 경계로 존재할 수도, 여러개의 세부 경계로 존재할 수도 있습니다.

어떻게 경계를 인식할 것인가?

경계 인식 1. 변화의 시점과 흐름이 다릅니다.

변화는 비즈니스의 결정사항 혹은 시스템의 요구사항에 시스템의 전반에 걸쳐 일어나게 됩니다.

이러한 변화는 그 주체가 같을 수도 있지만 대부분의 경우 변화의 주체가 다릅니다. 변화의 주체가 다르다면 그들은 서로 다르게 인식되어야 합니다.

우리가 SRP 를 이야기하는 것도 동일한 이유이지요.

경계 인식 2. 두번째 인식은 바로 일관성입니다.

일단 경계를 통해서 구획을 나누게 되면, 해당하는 구획 내에서 발생하는 일들은 구획 내에서 해결되어야 합니다.

경계 내부에서 일어나는 일들에 대해서는 그들의 상호작용을 통해 일관된 행동은 물론 데이터 또한 일관성 consistency 을 갖도록 해야합니다.

어떻게 경계를 다뤄야 하는가?

경계 다루기 1. 경계는 일관성을 책임져야 하기 때문에 그 경계가 명확해야 합니다.

코드는 물론 사용하는 언어도 명확해야 하고, 코드를 처음 마주하는 사람이 보더라도 경계에 대해 인식할 수 있어야 합니다.

또한 우리는 평생 한 코드만 작성하고 관리하지 않습니다.

언젠간 다른 동료들이 내가 작성한 코드를 유지보수하거나 신규 기능을 추가할 수 있기에, 경계는 명확할 수록 좋습니다.

코드레벨에서 경계를 강제적으로 분리하기 위해 gradle 에서는 multi module 과 dependency 를 이용하기도 합니다

경계 다루기 2. 경계는 지속적으로 관리되어야 합니다.

경계는 public interface 이기도 합니다.

한번 만들어지게 되면 다른 경계와 상호작용을 합니다.

상호작용을 한다는 것은 이 경계가 해야할 책임에 대해서 명확하게 인지하고 올바른 기능을 제공해야 합니다.

subscription 으로 알아보는 경계 나누기

이제 조금 더 실용적인 관점에서 구독 시스템을 통해 알아보겠습니다

구독 시스템은 다음과 같은 usecase 를 포함합니다

유저는 상품을 구독할 수 있다.

구독은 서비스 이용 권한을 나타낸다

구독은 서비스 이용시 주기적으로 청구가 발생한다

청구가 발생하면 정기 결제가 수행된다.

청구에 실패하면 n 번의 유예 기간을 제공한다

각각의 usecase 는 서로 다른 actor 에 의해 동작하게 되고 각각이 가져야할 책임이 명확하기 때문에 다음과 같이 경계를 나눕니다.

팀은 Subscription 과 Billing 그리고 Payment 의 변화의 시점이 다르다고 일관성을 적용해야할 규칙이 다르다고 규정하였습니다.

3가지의 경계는 다음과 같은 일을 수행할 수 있습니다

이렇게 3가지의 경계로 나눴다면, 그 경계 내부에서 일어나는 일들은 내부에서 일관성을 책임져야 합니다. 그 일관성을 책임지기 위한 여러가지 기법중 앞선 블로그에서 게시되었던 Aggregate 를 중심으로 데이터 저장하기 도 같은 맥락입니다.

경계 안에서 주의해야할 점

경계는 경계의 밖에서 일어나는 일들 때문에 구획 내에 존재하는 모델의 초점이 흐려지거나 혼란스러워져서는 안됩니다.

즉, 경계 밖의 지식이 경계 내부로 무분별하게 들어오지 않도록 조심해야 합니다.

2. 번역하기

앞서 경계를 나누면서 주의해야할 점이라고 이야기했던 것이 있습니다.

즉, 경계 밖의 지식이 경계 내부로 무분별하게 들어오지 않도록 조심해야 합니다.

일단 경계를 나눴다면 서로 독립된 모듈처럼 각개전투가 가능해야 합니다.

이론과 현실은 늘 다르죠 ㅎㅎ.. 우리가 개발하는 소프트웨어는 여러 경계들에 걸쳐 하나 이상의 기능을 수행하게 되므로 쉽지 않습니다.

결국 우리는 경계 외부와 잘 공생할 수 있는 환경을 만드는 것이 중요합니다.

이를 위해서 팀은 경계와 경계 사이에 위치하며 각각의 경계를 넘나들며 경계 내부의 문맥에 맞도록 데이터를 제공해주는 번역 계층 translation layer 를 만들었습니다.

Context, 경계 내부의 문맥

번역 계층을 이해하기 전에, 먼저 번역 계층이 왜 필요한지에 대해서 이야기를 해보려 합니다.

경계 내부는 외부와 완전 독립된 새로운 세계입니다.

시스템이 User 라는 개념의 정보들을 가지고 있다면 모든 경계에서 User 는 동일한 User 로 인식될 수 없습니다.

특정한 경계에서는 User 의 인증 정보가 필요할 수도 있고, 다른 경계에서는 User 의 주소 정보가 필요할 수도 있습니다.

물론 하나의 Super User 객체를 만들고 그 객체를 통해 해결하면 좋겠지만 한가지 큰 맹점이 존재합니다.

바로 SRP 관점에서 많은 불이익이 있습니다.

경계 내부에서는 문맥 Context 가 존재합니다.

Context 에 따라서 단순한 데이터도 다른 의미를 갖게 될 수 있습니다.

예를 들어보겠습니다.

public class Subscription {

    private final User user;

    private final ProductItem productItem;

}

위와 같은 클래스가 존재할 때, Subscription 은 다른 두개의 경계와 접해있습니다.

User 는 말 그대로 시스템 내에 존재하는 유저이지만, 구독(Subscription) 이라는 문맥 내에서는 구독을 시도하는 유저가 될 수 있습니다.

비슷한 관점으로 본다면 ProductItem 또한 구독하려는 상품이 될 수 있겠습니다.

public class Subscription {

    private final SubscribingUser user;

    private final SubscribableProductItem productItem;

}

구독의 문맥에서는 User 의 정보가 fully 필요하지 않습니다. 그럼 필요한 정보들만 잘 조합해서 사용하면 되는 것이죠.

Translation Layer, 번역 계층

번역 계층은 경계와 경계 사이에 위치하여 경계 바깥 세상과 내부 세상을 연결하는 통로 역할을 수행합니다.

이렇게 외부와 내부를 구분하여 외부 세상의 변경에도 영향을 적게 받을 수 있게 되는 것이지요.

앞서 말했다싶이 경계들 간의 변화의 속도와 수준이 다르기 때문에 번역 계층은 꼭 필요한 계층입니다.

실제로 번역 계층은 interface 의 implementation layer 라고도 할 수 있습니다.

이 번역 계층이 존재함으로써 외부에 대한 의존성을 최소화하며 변경에 대응하는 것입니다.

이런 장치를 통해 Subscription 경계 외부에서 발생하는 변화에 상대적으로 덜 의존적이게 설계할 수 있습니다.

경계 외부의 일에 대해서 내부 전파가 쉽지 않도록 만들기 위해서 팀은 gradle multi module 이라는 기술도 사용하고 있습니다.

번역 계층이 하는 일은 사실 단순합니다.

번역 계층은 subscription 이 정의한 문맥에 필요한 여러 정보들을 조합하여 경계 내부로 전달하는 일만 수행합니다.

이 말을 잘 보다보면, 익숙하게 사용하고 있는 기법 몇가지가 떠오를 수 있습니다.

우리가 interface 를 의존하여 실제 구현에 의존하지 않도록 하는 DIP 를 이용하면 쉽게 구현할 수 있습니다.

dependency inversion principal - wikipedia

DIP 를 코드 레벨에서 모듈 level 로 올린것과 다름 없습니다.

또한 dependency-impl 모듈의 구현 자체도 dependecy 에서 필요한 객체를 adapting 하는 역할만 수행합니다.

GoF 의 adapter pattern 을 이용하여 쉽게 구현할 수 있습니다.

https://en.wikipedia.org/wiki/Adapter_pattern

adapter pattern implementation - refactoring guru

3. 레거시 통합하기, Legacy Integration

레거시 시스템은 고통스럽지만 중요합니다.

지금까지 서비스를 성장시키기 위해 지탱하는 핵심 코어 기술들과 로직이 존재하며 이들 덕분에 우리가 개발하는 소프트웨어가 발전하기 위한 시간을 벌어주기도 합니다.

물론 레거시 시스템에 발목이 잡히기도 합니다. 완벽히 레거시 시스템을 제거할 수 없다면 우리는 그들과 잘 지내는 공생관계를 만들어야 합니다.

레거시 시스템의 지식이 경계 내부로 스며들지 않도록

레거시 시스템은 여러 경계에 걸쳐 다양한 이해관계자들과 상호작용하는 살아있는 코드입니다.

우리는 앞선 방법을 포함하여 여러 장치를 통해 새로운 프로젝트를 진행하면서 레거시 시스템이 가진 지식이 경계 내부로 스며들지 않도록 주의해야 합니다.

이러한 레거시 시스템이 구독 시스템에서 필요한 이유는 다음과 같았습니다.

admin page 에서 구독 정보를 보기 위해 레거시 데이터베이스 테이블 동기화

기존에 존재하는 인앱 구독 조회 정보를 지원

팀은 구독 시스템을 개발하면서 레거시 시스템 지원을 위해 이를 데이터 통합 (data-integration) 이라고 칭하기로 하였습니다.

데이터 통합 레이어는 Facade 이다.

데이터 통합 레이어는 구독의 정상적인 비즈니스 로직 최 끝단에 위치합니다.

끝에서 도메인 행위의 결과로 반환된 데이터들을 잘 조합하여 해당 데이터를 토대로 레거시 시스템을 지원합니다.

위 구조를 잘 보면 DataIntegrator 라는 컴포넌트는 Facade 처럼 구현될 수 있습니다.

facade pattern - wikipedia

facade pattern implementation - refactoring guru

핵심은 경계 내부의 핵심 비즈니스 서비스 레이어 혹은 도메인 레이어에서 레거시 통합에 대한 플로우나 로직을 모르게 하는 것입니다.

결국 정상 처리가 끝난 후 레거시 지원을 위한 데이터를 sourcing 하는 역할말 수행합니다.

data-integrator 자체가 facade 이므로 구현 자체는 여러가지 방법으로 수행될 수 있습니다.

대부분의 레거시 시스템은 우리가 개발하는 자원이 아니기 때문에 통신이 필요할 수도 있습니다.

동기적인 방법을 채택한다면 DB Connection 을 직접 생성하여 데이터를 업데이트할 수도 있을 것이고 HTTP 를 이용하여 기존에 존재하는 기능을 이용할 수도 있습니다.

동기로 발생하는 네트워크는 신뢰할 수 없다는 문제와 언제든지 지연이 발생할 수 있다는 것을 감안한다면 outbox table 이나 log tailing 과 그를 구현하는 aws dms 를 이용할 수도 있겠지요. (관련해서는 또한 팀에서 포스팅을 준비하고 있으니 지속적으로 아이들나라 블로그에 관심가져주세요 ㅎㅎ)

결국 핵심은 변하지 않습니다.

레거시 시스템의 지식이 경계 내부에 직접적으로 스며들지 않는 것입니다.

끝 마치며

주제와 비슷하지만 이야기하지 못한 것이 한가지 있습니다.

바로 외부 의존성에 대한 제어입니다.

제어하기 힘든 외부 의존성에 대해서도 팀은 여러가지 기술과 장치들을 통해 해결하고 있습니다.

아이들나라는 특히 외부와 연계된 시스템이 많기 때문에 이 주제만으로도 다양한 이야기와 해결해야할 문제들이 준비되어있습니다.

팀은 멋지고 좋은 코드를 작성하기 위해서 시간을 쏟기 보다 정해진 시간과 목표에 더 빠르고 잘 달성하기 위해서 노력합니다.

아이들나라에서는 함께 여러가지 도전적인 과제들에 대해서 실용적인 방법과 필요한 기술을 선택하여 과제를 달성해 나갈 여러분들을 기다리고 있습니다.
