# 삽입 정렬 알고리즘

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
- 선택 정렬보다 어려움
- 선택 정렬보다 효율적임
- O(n^2)
- 현재 리스트가 거의 정렬되어 있다면 매우 빠르게 동작
- 최선의 경우 O(N) 의 시간 복잡도

## 특징

- 선택 정렬보다 논리적으로 조금 더 어렵다.
- 선택 정렬보다 더 효율적이다.
- 현재 리스트가 거의 정렬되어 있다면 매우 빠른 동작을 보인다.
- 선택 정렬과 달리 최선의 경우 O(N)의 시간 복잡도를 갖는다.

[삽입 정렬 위키 이미지](https://ko.wikipedia.org/wiki/삽입_정렬)

## 정렬 과정

1. 배열의 3번 인덱스의 값을 (i-1) 2번 인덱스의 값과 비교한다.
2. 만약 2번 인덱스보다 **작으면** 2번 인덱스의 **왼쪽에 위치**하게 한다.
3. 만약 0번 인덱스보다 **크면** 2번 인덱스의 **그대로 둔다.**
4. 이 과정을 i-1번 인덱스가 0이 될 때 까지 반복한다.

## 소스 코드

```java
void insertionSort(int[] arr) {
  for(int i = 1; i < arr.length; i++) {

    int temp = arr[i]; // 정렬 타겟 변수
    int aux = i - 1; // 배열의 인덱스를 줄이며 비교할 인덱스 변수

    /* 배열을 아래로 내려가면서 적절한 위치로 insert하는 로직
    *  (aux >= 0) => arr[0] 까지 내려가는 조건
    *  (arr[aux] > temp) => 정렬 과정의 2번(작으면 왼쪽 위치).
    */
    while( (aux >= 0) && (arr[aux] > temp)) {
      arr[aux + 1] = arr[aux]; // 뒤로 한 칸씩 이동
      aux--;
    }
    arr[aux + 1] = temp;
  }
}
```

## 시간 복잡도

- 시간 복잡도는 O(N^2) 이며, 선택 정렬과 마찬가지로 **n까지 도는 반복문이 2번 중첩돼서 사용된다.**
- 최악의 시간복잡도: O(n^2)
- 최고의 시간복잡도: O(n)
- 평균의 시간복잡도: O(n^2)
