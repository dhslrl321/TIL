# Garbage Collection 이 동작하는 과정

- GC란?
  - Garbage Collection 으로 JVM 의 아키텍쳐 구성요소로 자동 메모리 관리 프로세스라고 함
  - 메모리 누수(Memory Leak) 해결 방안으로 사용자가 직접 객체의 메모리를 해제하지 않아도 JVM이 자동으로 메모리를 해제함
  - `stop-the-world` 를 통해 JVM 을 멈추고 메모리를 해제함
    - GC를 튜닝한다는 것은 `stop-the-world` 시간을 줄이는 것
  - Heap 이나 Method-Area 에 사용되지 않는 Object를 메모리에서 제거
  - JVM 은 사용자가 아니라 GC에게 메모리 해제 관심사를 부여하고 사용자는 코드에 집중할 수 있도록 하여 편리성을 더함

# GC 는 다음과 같은 연산을 통해서 자동으로 메모리 관리를 수행

- 메모리를 할당, 반납
- 애플리케이션이 요청하는대로 해당 메모리를 할당
- Application 의 어떤 부분이 메모리가 사용되고 있는지를 결정
- 메모리 재사용을 위해 메모리 회수

# GC 관심 대상

- 객체가 NULL 인 경우
- 블럭 실행 종료 후, 블럭 안에 생성된 객체
- 부모 객체가 NULL 인 경우, 포함하는 자식 객체

# GC 메모리 해제 과정 3단계

- GC 메모리를 해제하기 위해서는 Marking, Normal Deletion, Compacting 3단계를 거쳐야 한다
  - Marking
    1. 프로세스는 마킹을 호출한다.
    2. 각 객체마다 현재 사용중인지를 확인
    3. 참조되지 않은 객체와 참조되는 객체를 구분
  - Normal Deletion
    1. 참조되지 않은 객체를 제거하고 메모리 반환
    2. 메모리 Allocator 는 반환되어 비어진 블럭의 참조 위치를 저장하고 새로운 객체가 선언되면 비어진 블럭으로 할당
  - Compacting
    1. 퍼포먼스를 향상시키기 위해 참조되지 않은 객체를 제거하고 남은 객체를 묶음
    2. 메모리를 묶음으로 공간이 생겨서 새로운 메모리 할당 시에 더 쉽고 빠르게 진행 가능
- 근데 모든 객체를 Mark & Compact 하는 것은 비효율적임
  - 경험적으로 대부분의 객체가 생겨나자마자 쓰래기가 된다는 **약한 세대 가설, Weak generation hypothesis**이 있기 때문에
