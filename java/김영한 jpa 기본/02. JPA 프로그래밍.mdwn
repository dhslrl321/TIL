# JPA

- Java Persistence API
- ORM 기술 표준
  - ORM 이란?
    - Object Relational Mapping (객체 관계 매핑)
    - 객체는 객체대로 설계
    - 관계형 데이터베이스는 관계형 데이터베이스로 설계
    - ORM 프레임워크가 중간에서 매핑
- JPA는 Application 과 JDBC 사이에서 동작
  - `Java JPA (JDBC API) <-> DB`
  - 순서
    1. Entity 분석
    2. 자동으로 SELECT, INSERT SQL 생성
    3. JDBC API 생성
    4. 쿼리 날림 - 필요에 따라서 Result Set 에 매핑
    5. 패러다임의 불일치 해결
- Java Collections 에 값일 저장하고 빼오는 것과 같이 사용할 수 있게 하는 것

# JPA 역사

1. EJB (엔티티 빈, 자바 표준)
2. 하이버네이트 (오픈 소스)
3. JPA (자바 표준)

# JPA는 표준 명세

- JPA는 인터페이스의 모음
- 하이버네이트가 JPA를 구현하는 구현체

# JPA를 사용해야 하는 이유

- SQL 중심적인 개발에서 객체 중심적인 개발
- 생산성
  - 기존 : SELECT, UPDATE, INSERT 쿼리문을 직접 작성하고 ResultSet 에 매핑해야 한다.
  - JPA : 자바 컬렉션 객체에 넣듯 메서드 호출로 CRUD를 수행한다.
- 유지보수
  - 기존 : 새로운 칼럼을 추가해야 하는 경우, 기존의 INSERT, UPDATE, SELECT 쿼리 모두 수정을 해야 한다.
  - JPA : Entity 객체의 필드만 추가하면 된다.
- **패러다임 불일치 해결**
  - 상속
    - 상속 관계에 있는 테이블에 INSERT 할 때는 쿼리문을 2개를 사용해야 한다. 하지만 JPA가 알아서 2 개의 쿼리를 만들어서 쿼리문을 날린다.
    - 상속 관계에 있는 테이블에 SELECT 할 때는 JPA가 알아서 JOIN 해서 가져온다.
  - 연관관계
  - JPA는 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다.
- 성능
  - JPA는 Application 과 DB 사이의 중간 계층임
  - 이 말은 버파와 캐싱을 할 수 있다는 소리
  - 이걸 잘 다루면 엄청난 성능적 이점을 얻을 수 있음
    1. 캐싱 : 같은 트랜잭션에서는 같은 엔티티 반환
    2. 버퍼링 : 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
  - 즉시 로딩과 지연 로딩
    - 지연 로딩 : 객체가 실제 사용될 때 로딩
    - 즉시 로딩 : JOIN 으로 한번에 연관된 객체까지 미리 조회
- 데이터 접근 추상화와 벤더 독립성
- 표준

# 패러다임 불일치 해결

- JPA와 상속
- 객체와 연관관계
- JPA와 객체 그래프 탐색
- JPA와 비교
