# SOLID 원칙

# SRP

> There should never be more than one reason for a class to change

## 정의

- 특징
  - 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중해야 한다
    - 즉, 클래스를 변경하는 이유는 오직 하나여야 한다.
  - 다른 객체지향의 원칙의 기본이 됨
- 장점
  - 책임 영역이 명확해짐
    - 한 책임의 변경에서 다른 책임의 변경으로 인한 연쇄작용에서 자유로워짐
  - 대부분의 위험상황의 해결 방법은 SRP로 해결 가능
  - 리팩토링의 근본 정신
    - 리팩토링이 잘됨
- 단점
  - 이론은 쉬우나 적용하기가 까다로움
    - 실무 프로세스는 매우 복잡하기 때문
- 실천 방법
  - 도메인에 대한 업무 이해가 선행되어져야 한다.
  - 책임이라는 단어를 상기하는 많은 연습과 경험이 필요
- 적용 이슈
  - 클래스는 자신의 이름이 나타내는 일을 해야함 (올바른 이름이 클래스의 책임을 나타내는 좋은 방법)
  - 무조건 책임을 분리한다고 해서 SRP 가 적용되지 않음
    - 결합력이 있다면 SRP 라 하지 않음

## 우리의 코드

```java

```

# OCP

> You should be able to extend a classes behavior, without modifying it

- 특징
  - 버틀란드 메이어가 1998년도에 쓴 책인 객체지향 소프트웨어 설계라는 책에서 정의한 내용
    - 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리
  - 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나면 안됨
  - 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다
    - 로버트 마틴 : OCP 는 재사용 가능한 코드를 만드는 기반이다
  - 추상화와 다형성이 가장 중요한 원리

## 우리의 코드

```java

```

# 리스코프 치환의 원칙

> Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it

- 서브 타임은 언제나 기반 타입으로 교체될 수 있어야 한다.
  - 서브 타입은 언제나 기반 타입과 호환된다
- 궁극적으로는 다형성을 통한 확장성을 목표로 함

# 인터페이스 분리의 원칙

- 특징
  - 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다
  - 하나의 일반적인 (Generic) 한 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다
  - 클래스 관점에서는 SRP, 인터페이스 관점에서는 ISP
- 실천 방법
  - 클래스의 상속을 이용해서 인터페이스를 나누자
  - Delegation 을 이용해서 인터페이스를 나눈다
    - 특정한 일의 책임을 다른 클래스나 메서드에게 맡긴다

# 의존 관계의 역전 원칙

- 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전
- 추상을 매개로 메시지를 주고 받음으로 관계를 최대한 느슨하게 만드는 원칙
