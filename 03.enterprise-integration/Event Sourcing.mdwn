# Event Sourcing

- 데이터의 현재 상태의 결과만 저장하는 것이 아니라 데이터에 수행된 전체 작업을 추가 전용 저장소(event store) 에 저장하는 패턴
  - 데이터 모델과 비즈니스 도메인을 동기화할 필요가 없다
  - 확장성, 응답성이 향상된다.

# 기존의 문제점

- 기존 : 원본 데이터의 상태를 CRUD 를 통해 항상 업데이트한다.
  - 데이터를 업데이트 할 때, transaction lock 을 사용한다.
- 문제점
  - 성능 및 응답 속도가 저하된다.
  - 동시에 많은 사용자가 해당 row 에 작업을 수행할 때 lock 으로 인한 conflict 가 자주 발생할 수 있다.

# 해결 방법

- 각각 추가 전용 저장소에 애플리케이션 코드가 수행한 데이터의 변경 이벤트를 이벤트 저장소로 저장한다.
  - 이벤트 저장소에 저장된 이벤트들은 구체화된 뷰를 생성하는 데에 사용될 수 있다.

# 장점

- 이벤트는 뷸변하다
  - 트랜잭션 처리 중 (경합, 경쟁)이 없다
  - Presentation level 이나 UI 의 성능이 훨씬 향상된다.
- 이벤트 스토어는 단순 이벤트를 저장하기 때문에 구현과 관리를 분리하고 간소화 할 수 있다
- 이벤트 자체가 비즈니스에 대해 유용한 정보가 될 수 있다.

> 일반적으로 이벤트 소싱은 구체화된 뷰를 이용하여 CQRS 패턴과 결합될 수 있다.

# 문제 및 고려 사항

- 데이터의 정합성이 깨질 수 있다.
  - 데이터 프로젝션을 생성할 때만 시스템의 데이터가 일치한다
    - 구체화된 뷰를 생성하거나 event replay 를 통해서 데이터를 생성하는 시점에만 시스템과 데이터가 일치한다.
  - 요청의 처리 결과와 이벤트 스토어에 이벤트 추가, 게시 및 이벤트 소비자의 이벤트 처리 사이에 약간의 지연이 발생할 수 있다.
- 이벤트 저장소에 저장된 이벤트는 영구 불변적 정보이므로 데이터가 업데이트 되면 안된다.
  - 이벤트 저장소의 데이터는 불변함을 보장해야 한다.
  - 보정을 해야한다면 보정 이벤트를 추가하는 것이 맞지 과거의 이벤트를 수정하는 것은 옳지 않다.
- 여러 애플리케이션이 이벤트 스토어에 이벤트를 저장할 수 있는데, 이때 이벤트의 순서가 중요하다.
  - 모든 이벤트에 타임스탬프를 추가하여 문제를 해결하곤 한다
- 이벤트 history 가 많은 경우는 이벤트를 replay 하는데, 많은 성능 비용이 발생한다.
  - 특정 간격의 스냅샷으로 해결할 수 있다.
  - 스냅샷에서 해당 시점 이후에 발생한 이벤트를 재생하면 엔티티의 현재 상태를 더 빠르게 확인할 수 있다.
- 이벤트는 한 번 이상 발생될 수 있다.
  - 한 번 이상이라는 말이 중요하다
  - 이벤트 소비자는 idempotent 해야 한다, 멱등해야 한다
    - 멱등성 : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다
    - 즉, 메서드가 여러 번 실행되어도 결과는 같으므로 안전하게 사용할 수 있다는 의미다

# 이 패턴을 사용해야 하는 경우

- 비즈니스 상으로 이벤트의 과거 이력이 중요한 경우
- 데이터 업데이트에 대한 충돌을 최소화 하거나 완전히 방지해야 하는 경우

# 이 패턴을 추천하지 않는 경우

- 도메인이 단순한 경우
  - 복잡성이 증가할 수 있다.
- 데이터 뷰에 대한 실시간 업데이트가 필요한 경우
  - 프로젝션 후에만 데이터가 일치하기 때문에
- 데이터 충돌이 매우 적은 시스템
  - 한 로우를 동시에 접근하려는 일이 드물다면 효율이 좋지 않다
